<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Drill-Down D3 Network Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { margin:0; font-family: system-ui, Arial, sans-serif; }
        svg { width: 100vw; height: 100vh; display: block; background:#f8f9fa; }
        .node { stroke: #fff; stroke-width: 1.2px; }
        .label { font-size: 12px; pointer-events: none; }
        .highlight { stroke: #d62728; stroke-width: 3px; }
        /* Overlay drilldown panel */
        #overlay { position:fixed; inset:0; background:rgba(0,0,0,0.45); display:none; align-items:center; justify-content:center; }
        #panel { width:90%; max-width:1100px; height:80%; background:#fff; border-radius:8px; box-shadow:0 8px 40px rgba(0,0,0,0.35); position:relative; overflow:hidden; display:flex; flex-direction:column; }
        #panel-header { padding:12px 16px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid #e2e2e2; background:#fafafa; }
        #panel-title { font-size:16px; font-weight:600; }
        #close-btn { background:#dc3545; border:none; color:#fff; padding:8px 14px; border-radius:4px; font-size:13px; cursor:pointer; }
        #panel-body { flex:1; position:relative; }
        #panel-body svg { width:100%; height:100%; background:#fff; }
        .product-node { stroke:#222; stroke-width:0.6px; cursor:grab; }
        .product-label { font-size:11px; pointer-events:none; }
        .tooltip { position:absolute; background:rgba(0,0,0,0.75); color:#fff; padding:4px 6px; border-radius:4px; font-size:11px; pointer-events:none; display:none; }
        /* Internal circle labels */
        .cluster-id { font-size:11px; font-weight:600; fill:#fff; text-anchor:middle; pointer-events:none; }
        .aisle-name-inner { font-size:11px; font-weight:600; fill:#fff; text-anchor:middle; pointer-events:none; }
        /* GMM ellipse styling */
        .cluster-ellipse { fill:rgba(0,0,0,0.05); stroke:#555; stroke-width:1px; pointer-events:none; }
        .cluster-ellipse.hidden { display:none; }
    </style>
</head>
<body>
<div id="ui-bar" style="position:fixed;top:0;left:0;right:0;height:48px;background:#212529;color:#fff;display:flex;align-items:center;gap:16px;padding:0 18px;font-family:system-ui,Arial,sans-serif;z-index:20;box-shadow:0 2px 6px rgba(0,0,0,0.25);">
    <div style="font-size:15px;font-weight:600;letter-spacing:.5px;">Product Substitution Hierarchy</div>
    <input id="search-input" type="text" placeholder="Search aisle / cluster / product" style="flex:1;max-width:420px;padding:6px 10px;border-radius:4px;border:1px solid #555;background:#343a40;color:#fff;font-size:13px;" />
    <button id="search-btn" style="padding:6px 12px;font-size:13px;border:1px solid #888;border-radius:4px;background:#ffc107;color:#222;cursor:pointer;">Search</button>
    <button id="fit-btn" style="padding:6px 10px;font-size:12px;border:1px solid #888;border-radius:4px;background:#fff;color:#222;cursor:pointer;">Fit View</button>
    <button id="gmm-btn" style="padding:6px 10px;font-size:12px;border:1px solid #888;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">GMM Layout</button>
    <button id="hier-btn" style="padding:6px 10px;font-size:12px;border:1px solid #888;border-radius:4px;background:#198754;color:#fff;cursor:pointer;">Hierarchical</button>
    <div id="search-status" style="min-width:160px;font-size:12px;color:#adb5bd;"></div>
</div>
<svg></svg>
<!-- Minimap removed per request -->
<div id="overlay">
    <div id="panel">
        <div id="panel-header">
            <div id="panel-title">Cluster</div>
            <button id="close-btn">Close</button>
        </div>
        <div id="panel-body">
            <svg id="products-svg"></svg>
            <div id="tooltip" class="tooltip"></div>
        </div>
    </div>
</div>
<script>
// Simplified P2-P3 graph: only aisles (P3) and clusters (P2) with edges type P2_P3.
d3.json("../data/processed/drilldown_graph.json").then(function(graph) {
    // Attempt to load GMM layout augmentation; proceed silently if missing
    let gmmData = null;
    try {
        // d3.json returns a promise; we'll chain below using then()
    } catch (e) {}
    // We'll wrap main build logic in a function to allow async second load
    function build(gmmAug) {
    const svg = d3.select("svg"),
          width = window.innerWidth,
          height = window.innerHeight;
    svg.attr("width", width).attr("height", height).style('margin-top','48px');
    // Root group to apply zoom/pan transforms
    const root = svg.append('g').attr('class','root');

    // Filter nodes and links for P2-P3 only
    const aisles = graph.nodes.filter(d => d.type === 'P3_Aisle');
    const clusters = graph.nodes.filter(d => d.type === 'P2_Cluster');

    // If GMM augmentation provided, merge centroid/ellipse fields into clusters
    if (gmmAug) {
        const augMap = new Map();
        gmmAug.nodes.filter(n => n.type === 'P2_Cluster').forEach(n => {
            augMap.set(n.id, n);
        });
        clusters.forEach(c => {
            const aug = augMap.get(c.id);
            if (aug && aug.centroid_x !== undefined) {
                c.centroid_x = aug.centroid_x;
                c.centroid_y = aug.centroid_y;
                c.eig1 = aug.eig1;
                c.eig2 = aug.eig2;
                c.angle_deg = aug.angle_deg;
            }
        });
    }
    const links = graph.links.filter(l => l.type === 'P2_P3');

    // Build mapping aisle -> its clusters from links (source cluster, target aisle)
    const aisleToClusters = d3.group(clusters, c => c.aisle_name);

    // Color scale by aisle
    const color = d3.scaleOrdinal().domain(aisles.map(a => a.name)).range(d3.schemeTableau10.concat(d3.schemeCategory10));

    // Layout aisles horizontally (wrap if needed)
    const aisleCols = Math.ceil(Math.sqrt(aisles.length));
    const aisleGapX = Math.max(140, width / Math.max(aisleCols, 1));
    const aisleGapY = 180;

    aisles.forEach((a, i) => {
        const col = i % aisleCols;
        const row = Math.floor(i / aisleCols);
        a.x = 80 + col * aisleGapX;
        a.y = 80 + row * aisleGapY;
    });

    // Position clusters under their aisle in a grid
    clusters.forEach(c => {
        const parent = aisles.find(a => a.name === c.aisle_name);
        const siblings = aisleToClusters.get(c.aisle_name) || [];
        const idx = siblings.indexOf(c);
        const cols = Math.ceil(Math.sqrt(siblings.length));
        const gap = 42;
        const col = idx % cols;
        const row = Math.floor(idx / cols);
        if (parent) {
            c.x = parent.x - ((cols-1)*gap)/2 + col * gap;
            c.y = parent.y + 90 + row * 70;
        } else {
            // fallback random if no parent found
            c.x = Math.random() * width;
            c.y = Math.random() * height;
        }
        // Store hierarchical position for toggling
        c.hier_x = c.x;
        c.hier_y = c.y;
    });

    aisles.forEach(a => { a.hier_x = a.x; a.hier_y = a.y; });

    // Draw links (cluster -> aisle)
    const link = root.append('g')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.6)
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-width', 1.2)
        .attr('x1', d => clusters.find(c => c.id === d.source).x)
        .attr('y1', d => clusters.find(c => c.id === d.source).y)
        .attr('x2', d => aisles.find(a => a.id === d.target).x)
        .attr('y2', d => aisles.find(a => a.id === d.target).y);

    // Draw aisle nodes as groups with internal abbreviated label
    function abbreviateAisle(name){
        if(!name) return '';
        const maxChars = 11;
        return name.length > maxChars ? name.slice(0, maxChars-1) + '…' : name;
    }
    const aisleGroup = root.append('g')
        .selectAll('g.aisle-group')
        .data(aisles)
        .join('g')
        .attr('class','aisle-group')
        .attr('transform', d => `translate(${d.x},${d.y})`);
    aisleGroup.append('circle')
        .attr('class','node aisle')
        .attr('r',30)
        .attr('fill', d => color(d.name));
    aisleGroup.append('text')
        .attr('class','aisle-name-inner')
        .attr('dy','0.35em')
        .text(d => abbreviateAisle(d.name))
        .append('title')
        .text(d => d.name);

    // Draw cluster nodes as groups with internal cluster number
    function clusterNumber(d){
        if(d.cluster_id !== undefined) return d.cluster_id;
        const parts = (d.name||'').split(/\s+/); const num = +parts[1];
        return isNaN(num)? '' : num;
    }
    const ellipseLayer = root.append('g').attr('class','ellipse-layer');

    const clusterGroup = root.append('g')
        .selectAll('g.cluster-group')
        .data(clusters)
        .join('g')
        .attr('class','cluster-group')
        .attr('transform', d => `translate(${d.x},${d.y})`)
        .style('cursor','pointer')
        .on('click', (event,d) => openClusterPanel(d));
    clusterGroup.append('circle')
        .attr('class','node cluster')
        .attr('r',16)
        .attr('fill', d => color(d.aisle_name));
    clusterGroup.append('text')
        .attr('class','cluster-id')
        .attr('dy','0.35em')
        .text(d => clusterNumber(d));
    // Reference selection of cluster circles for highlighting
    const clusterNode = clusterGroup.select('circle.cluster');

    // Prepare GMM ellipses (initially hidden until GMM layout activated)
    function ellipseRadiiScale() { return 55; } // scale factor for eigen radii
    const ellipses = ellipseLayer.selectAll('ellipse')
        .data(clusters.filter(c => c.eig1 !== undefined))
        .join('ellipse')
        .attr('class','cluster-ellipse hidden')
        .attr('cx', c => c.x)
        .attr('cy', c => c.y)
        .attr('rx', c => c.eig1 * ellipseRadiiScale())
        .attr('ry', c => c.eig2 * ellipseRadiiScale())
        .attr('transform', c => `translate(${c.x},${c.y}) rotate(${c.angle_deg || 0}) translate(${-c.x},${-c.y})`)
        .attr('stroke', c => color(c.aisle_name));

    // -------- AUTOFIT & ZOOM --------
    function computeBounds() {
        const all = aisles.concat(clusters);
        const pad = 50;
        const minX = d3.min(all, d => d.x - (d.type === 'P3_Aisle' ? 30 : 16)) - pad;
        const maxX = d3.max(all, d => d.x + (d.type === 'P3_Aisle' ? 30 : 16)) + pad;
        const minY = d3.min(all, d => d.y - (d.type === 'P3_Aisle' ? 30 : 16)) - pad;
        const maxY = d3.max(all, d => d.y + (d.type === 'P3_Aisle' ? 30 : 16)) + pad;
        return {minX, minY, maxX, maxY};
    }
    function fitView(animated=true){
        const b = computeBounds();
        const vw = width; const vh = height;
        const bw = b.maxX - b.minX; const bh = b.maxY - b.minY;
        const scale = Math.min( (vw-40)/bw, (vh-40)/bh );
        const tx = vw/2 - (b.minX + bw/2)*scale;
        const ty = vh/2 - (b.minY + bh/2)*scale;
        const transform = d3.zoomIdentity.translate(tx, ty).scale(scale);
        if(animated){ svg.transition().duration(650).call(zoom.transform, transform); } else { svg.call(zoom.transform, transform); }
    }
    const zoom = d3.zoom()
        .scaleExtent([0.3, 6])
        .on('zoom', (event) => { root.attr('transform', event.transform); });
    svg.call(zoom);
    d3.select('#fit-btn').on('click', () => fitView(true));
    // Layout toggle buttons
    const gmmBtn = d3.select('#gmm-btn');
    const hierBtn = d3.select('#hier-btn');

    let gmmActive = false;
    let clusterSim = null;

    function activateGmmLayout() {
        if (gmmActive) return;
        gmmActive = true;
        gmmBtn.style('opacity',1); hierBtn.style('opacity',0.6);
        // Map normalized centroid (0..1) to viewport area (with margins)
        const margin = 60;
        clusters.forEach(c => {
            if (c.centroid_x !== undefined) {
                c.x = margin + c.centroid_x * (width - margin*2);
                c.y = margin + c.centroid_y * (height - margin*2);
            }
        });
        // Show ellipses and update positions
        ellipses.classed('hidden', false)
            .attr('cx', c => c.x)
            .attr('cy', c => c.y)
            .attr('rx', c => c.eig1 * ellipseRadiiScale())
            .attr('ry', c => c.eig2 * ellipseRadiiScale())
            .attr('transform', c => `translate(${c.x},${c.y}) rotate(${c.angle_deg || 0}) translate(${-c.x},${-c.y})`);
        // Start force simulation for clusters (allow dragging adjustment)
        clusterSim = d3.forceSimulation(clusters)
            .force('charge', d3.forceManyBody().strength(-40))
            .force('collision', d3.forceCollide().radius(22))
            .alphaDecay(0.05)
            .on('tick', () => {
                clusterGroup.attr('transform', d => `translate(${d.x},${d.y})`);
                ellipses.attr('cx', d => d.x).attr('cy', d => d.y)
                    .attr('transform', d => `translate(${d.x},${d.y}) rotate(${d.angle_deg || 0}) translate(${-d.x},${-d.y})`);
                // Update link lines (cluster->aisle) if desired; aisles stay fixed
                link.attr('x1', d => clusters.find(c => c.id === d.source).x)
                    .attr('y1', d => clusters.find(c => c.id === d.source).y);
            });
        // Dragging behavior
        clusterGroup.call(d3.drag()
            .on('start', (event,d) => { if(!event.active) clusterSim.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; })
            .on('drag', (event,d) => { d.fx=event.x; d.fy=event.y; })
            .on('end', (event,d) => { if(!event.active) clusterSim.alphaTarget(0); d.fx=null; d.fy=null; })
        );
        fitView(true);
        d3.select('#search-status').text('GMM layout active. Drag clusters; click to drill down.');
    }

    function activateHierLayout() {
        // Always provide feedback, even if already hierarchical
        if (!gmmActive) {
            // Pulse clusters to show action
            clusterNode.transition().duration(250).attr('stroke-width',3).transition().duration(400).attr('stroke-width',1.2);
            d3.select('#search-status').text('Already in hierarchical layout. Click a cluster to explore products.');
            return;
        }
        gmmActive = false;
        hierBtn.style('opacity',1); gmmBtn.style('opacity',0.6);
        if (clusterSim) { clusterSim.stop(); clusterSim = null; }
        // Restore hierarchical positions
        clusters.forEach(c => { c.x = c.hier_x; c.y = c.hier_y; });
        ellipses.classed('hidden', true);
        clusterGroup.attr('transform', d => `translate(${d.x},${d.y})`);
        link.attr('x1', d => clusters.find(c => c.id === d.source).x)
            .attr('y1', d => clusters.find(c => c.id === d.source).y);
        fitView(true);
        d3.select('#search-status').text('Hierarchical layout active. Click a cluster to explore products.');
    }

    gmmBtn.on('click', activateGmmLayout);
    hierBtn.on('click', activateHierLayout);
    // Initial fit
    fitView(false);

    // ---------- SEARCH FUNCTIONALITY ----------
    const searchInput = d3.select('#search-input');
    const searchBtn = d3.select('#search-btn');
    const searchStatus = d3.select('#search-status');

    function focusNode(node){
        if(!node) return;
        const targetScale = 1.8; // desired zoom in
        const clampScale = Math.min(Math.max(targetScale, 0.3), 6);
        const tx = width/2 - node.x * clampScale;
        const ty = height/2 - node.y * clampScale;
        const transform = d3.zoomIdentity.translate(tx, ty).scale(clampScale);
        svg.transition().duration(600).call(zoom.transform, transform);
        // temporary highlight
        if(node.type === 'P2_Cluster') {
            clusterNode.classed('highlight', c => c === node);
            setTimeout(()=> clusterNode.classed('highlight', false), 1800);
        } else if(node.type === 'P3_Aisle') {
            aisleGroup.selectAll('circle.aisle').classed('highlight', a => a === node);
            setTimeout(()=> aisleGroup.selectAll('circle.aisle').classed('highlight', false), 1800);
        }
    }

    function search(termRaw){
        const term = (termRaw||'').trim().toLowerCase();
        if(!term){ searchStatus.text(''); return; }
        // Try aisle exact
        let node = aisles.find(a => a.name.toLowerCase() === term);
        // Try cluster id or name "cluster n"
        if(!node){
            const m = term.match(/^cluster\s*(\d+)$/); if(m){
                node = clusters.find(c => clusterNumber(c)==+m[1]);
            } else {
                // cluster id only
                const numOnly = term.match(/^(\d+)$/); if(numOnly){ node = clusters.find(c => clusterNumber(c)==+numOnly[1]); }
            }
        }
        // Try contains aisle substring
        if(!node){ node = aisles.find(a => a.name.toLowerCase().includes(term)); }
        // Try product name (search drilldown lists)
        let product = null;
        if(!node){
            // Build product index once
            if(!search._products){
                const allProducts = Object.values(graph.drilldown.cluster_to_products).flat();
                search._products = allProducts;
            }
            product = search._products.find(p => p.name && p.name.toLowerCase().includes(term));
            if(product){
                // find cluster node
                node = clusters.find(c => clusterNumber(c) == product.cluster_id);
            }
        }
        if(node){
            focusNode(node);
            searchStatus.text(product? 'Focused product in cluster '+clusterNumber(node) : 'Focused '+ node.type.replace('_',' ').toLowerCase());
            // If product, open panel directly
            if(product){ openClusterPanel(node); }
        } else {
            searchStatus.text('Not found');
        }
    }
    searchBtn.on('click', () => search(searchInput.node().value));
    searchInput.on('keydown', (e) => { if(e.key==='Enter'){ search(searchInput.node().value); }});

    // Minimap code removed. Zoom handler remains simple.

    // ---- Dynamic font sizing for labels inside circles ----
    function fitText(selection, radius, minSize=7, maxSize=12) {
        selection.each(function() {
            const textEl = d3.select(this);
            let size = maxSize;
            textEl.style('font-size', size + 'px');
            // shrink until fits or reach min
            while (this.getBBox().width > radius*1.7 && size > minSize) { // 1.7 accommodates multi-char width
                size -= 1;
                textEl.style('font-size', size + 'px');
            }
            // If still too wide, truncate and add ellipsis (avoid layout break)
            if (this.getBBox().width > radius*1.9) {
                const original = textEl.text();
                const chars = original.split('');
                while (chars.length && this.getBBox().width > radius*1.6) {
                    chars.pop();
                    textEl.text(chars.join('') + '…');
                }
                textEl.append('title').text(original);
            }
        });
    }
    // Apply fitting after initial render
    fitText(aisleGroup.selectAll('text.aisle-name-inner'), 30, 7, 13);
    fitText(clusterGroup.selectAll('text.cluster-id'), 16, 8, 14);

    // External aisle labels no longer needed (inner label used)

    // External cluster labels removed (number inside circle)

    // ---- Drilldown logic ----
    const overlay = d3.select('#overlay');
    const panelTitle = d3.select('#panel-title');
    const productsSvg = d3.select('#products-svg');
    const tooltip = d3.select('#tooltip');
    d3.select('#close-btn').on('click', closePanel);

    function parseClusterId(cluster) {
        // cluster.name format: "Cluster N"
        if (cluster.cluster_id !== undefined) return cluster.cluster_id;
        const parts = (cluster.name || '').split(/\s+/);
        const num = +parts[1];
        return isNaN(num) ? cluster.name : num;
    }

    function getClusterProducts(cluster) {
        const cid = parseClusterId(cluster);
        // keys in JSON may be strings; attempt both
        return graph.drilldown.cluster_to_products[cid] || graph.drilldown.cluster_to_products[String(cid)] || [];
    }

    function openClusterPanel(cluster) {
        // Highlight selected cluster
    clusterNode.classed('highlight', c => c === cluster);
        const products = getClusterProducts(cluster);
        panelTitle.text(`${cluster.name} – Products (${products.length})`);
        overlay.style('display','flex');
        renderProducts(products, cluster);
    }

    function closePanel() {
        overlay.style('display','none');
        productsSvg.selectAll('*').remove();
        clusterNode.classed('highlight', false);
        hideTooltip();
    }

    function renderProducts(products, cluster) {
        productsSvg.selectAll('*').remove();
        const pw = document.querySelector('#panel-body').clientWidth;
        const ph = document.querySelector('#panel-body').clientHeight;
        productsSvg.attr('viewBox', `0 0 ${pw} ${ph}`);
        // Safety cap to avoid huge rendering cost
        const list = products.slice(0, 600);

        // Basic force layout for products
        const sim = d3.forceSimulation(list)
            .force('charge', d3.forceManyBody().strength(-20))
            .force('center', d3.forceCenter(pw/2, ph/2))
            .force('collision', d3.forceCollide().radius(18))
            .on('tick', ticked);

        const nodeG = productsSvg.append('g').selectAll('g.prod')
            .data(list, d => d.id)
            .enter().append('g')
            .attr('class','prod')
            .call(drag(sim));

        nodeG.append('circle')
            .attr('class','product-node')
            .attr('r', 14)
            .attr('fill', cluster ? color(cluster.aisle_name) : '#888')
            .on('mouseover', (event,d) => showTooltip(event,d.name))
            .on('mouseout', hideTooltip);

        nodeG.append('text')
            .attr('class','product-label')
            .attr('text-anchor','middle')
            .attr('y', 4)
            .text(d => d.name);

        function ticked() {
            nodeG.attr('transform', d => `translate(${d.x},${d.y})`);
        }

        function drag(simulation) {
            function dragstarted(event,d){ if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; }
            function dragged(event,d){ d.fx=event.x; d.fy=event.y; }
            function dragended(event,d){ if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; }
            return d3.drag().on('start',dragstarted).on('drag',dragged).on('end',dragended);
        }
    }

    function showTooltip(event,text){ tooltip.style('display','block').html(text).style('left',(event.pageX+10)+'px').style('top',(event.pageY+10)+'px'); }
    function hideTooltip(){ tooltip.style('display','none'); }

    // Initial guidance
    if (clusters.some(c => c.centroid_x !== undefined)) {
        d3.select('#search-status').text('Hierarchical layout loaded. GMM data available – press GMM Layout to view.');
    } else {
        d3.select('#search-status').text('GMM layout unavailable: run export_gmm_layout_json.py then refresh. Click a cluster to explore products.');
        gmmBtn.text('GMM Layout (generate JSON to enable)')
            .style('background','#6c757d')
            .style('cursor','not-allowed')
            .attr('disabled',true)
            .on('click', null); // remove handler
    }
    hierBtn.style('opacity',1); gmmBtn.style('opacity',0.6);
    }
    // Load optional GMM augmentation then build
    d3.json("../data/processed/drilldown_graph_gmm.json").then(gmm => { gmmData = gmm; build(gmmData); }).catch(() => build(null));
});
</script>
</body>
</html>